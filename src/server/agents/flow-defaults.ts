import type { FlowTemplate, FlowNode, FlowEdge } from "../../shared/flow-types.ts";
import { nanoid } from "nanoid";

/** Layout helpers for auto-positioning nodes */
const X_SPACING = 280;
const Y_SPACING = 150;
const Y_CENTER = 200;

function makeNode(
  id: string,
  type: FlowNode["type"],
  data: FlowNode["data"],
  x: number,
  y: number,
): FlowNode {
  return { id, type, data, position: { x, y } };
}

function makeEdge(source: string, target: string, sourceHandle?: string, label?: string): FlowEdge {
  return { id: `e-${source}-${target}${sourceHandle ? `-${sourceHandle}` : ""}`, source, target, sourceHandle, label };
}

/**
 * Generate the default "build" flow template that replicates the hardcoded
 * buildExecutionPlan logic in orchestrator.ts.
 */
export function generateBuildDefault(): FlowTemplate {
  const now = Date.now();
  const nodes: FlowNode[] = [];
  const edges: FlowEdge[] = [];

  // Column positions
  let col = 0;

  // Research
  const research = makeNode("research", "agent", {
    type: "agent",
    agentName: "research",
    inputTemplate: "Analyze user request and identify requirements. Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER);
  nodes.push(research);

  // Architect
  col++;
  const architect = makeNode("architect", "agent", {
    type: "agent",
    agentName: "architect",
    inputTemplate: "Design the component architecture and test plan based on the research agent's requirements (provided in Previous Agent Outputs). Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER);
  nodes.push(architect);
  edges.push(makeEdge("research", "architect"));

  // Condition: needsBackend?
  col++;
  const condNeedsBackend = makeNode("cond-backend", "condition", {
    type: "condition",
    mode: "predefined",
    predefined: "needsBackend",
    label: "Needs Backend?",
  }, col * X_SPACING, Y_CENTER);
  nodes.push(condNeedsBackend);
  edges.push(makeEdge("architect", "cond-backend"));

  // Frontend Dev
  col++;
  const frontendDev = makeNode("frontend-dev", "agent", {
    type: "agent",
    agentName: "frontend-dev",
    inputTemplate: "Implement the React components defined in the architect's plan (provided in Previous Agent Outputs). A test plan is included in the architect's output — write test files alongside your components following the plan. Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER - Y_SPACING / 2);
  nodes.push(frontendDev);
  edges.push(makeEdge("cond-backend", "frontend-dev", "true", "yes"));
  edges.push(makeEdge("cond-backend", "frontend-dev", "false", "no"));

  // Backend Dev (conditional)
  const backendDev = makeNode("backend-dev", "agent", {
    type: "agent",
    agentName: "backend-dev",
    inputTemplate: "Implement the backend API routes and server logic defined in the architect's plan (provided in Previous Agent Outputs). Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER + Y_SPACING / 2);
  nodes.push(backendDev);
  edges.push(makeEdge("cond-backend", "backend-dev", "true", "yes"));

  // Styling
  col++;
  const styling = makeNode("styling", "agent", {
    type: "agent",
    agentName: "styling",
    inputTemplate: "Apply design polish to the components created by frontend-dev, using the research requirements for design intent (both provided in Previous Agent Outputs). Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER);
  nodes.push(styling);
  edges.push(makeEdge("frontend-dev", "styling"));
  edges.push(makeEdge("backend-dev", "styling"));

  // Parallel reviewers
  col++;
  const codeReview = makeNode("code-review", "agent", {
    type: "agent",
    agentName: "code-review",
    inputTemplate: "Review and fix all code generated by dev and styling agents (provided in Previous Agent Outputs). Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER - Y_SPACING);
  nodes.push(codeReview);
  edges.push(makeEdge("styling", "code-review"));

  const security = makeNode("security", "agent", {
    type: "agent",
    agentName: "security",
    inputTemplate: "Security review all code generated by the dev agents (provided in Previous Agent Outputs). Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER);
  nodes.push(security);
  edges.push(makeEdge("styling", "security"));

  const qa = makeNode("qa", "agent", {
    type: "agent",
    agentName: "qa",
    inputTemplate: "Validate the implementation against the research requirements (both provided in Previous Agent Outputs). Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER + Y_SPACING);
  nodes.push(qa);
  edges.push(makeEdge("styling", "qa"));

  // Remediation
  col++;
  const remediation = makeNode("remediation", "post-action", {
    type: "post-action",
    actionType: "remediation-loop",
    label: "Remediation",
  }, col * X_SPACING, Y_CENTER);
  nodes.push(remediation);
  edges.push(makeEdge("code-review", "remediation"));
  edges.push(makeEdge("security", "remediation"));
  edges.push(makeEdge("qa", "remediation"));

  return {
    id: `default-build-${nanoid(8)}`,
    name: "Default Build Pipeline",
    description: "Research → Architect → Dev (frontend + optional backend) → Styling → Reviews → Remediation",
    intent: "build",
    version: 1,
    enabled: true,
    nodes,
    edges,
    createdAt: now,
    updatedAt: now,
    isDefault: true,
  };
}

/**
 * Generate the default "fix" flow template that replicates buildFixPlan.
 */
export function generateFixDefault(): FlowTemplate {
  const now = Date.now();
  const nodes: FlowNode[] = [];
  const edges: FlowEdge[] = [];
  let col = 0;

  // Condition: scope
  const condScope = makeNode("cond-scope", "condition", {
    type: "condition",
    mode: "expression",
    expression: "scope === 'styling'",
    label: "Styling only?",
  }, col * X_SPACING, Y_CENTER);
  nodes.push(condScope);

  // Quick-edit: styling
  col++;
  const stylingQuick = makeNode("styling-quick", "agent", {
    type: "agent",
    agentName: "styling",
    inputTemplate: "Fix the following styling issue in the existing code. Use read_file/list_files to inspect relevant files and keep changes minimal and targeted. Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER - Y_SPACING);
  nodes.push(stylingQuick);
  edges.push(makeEdge("cond-scope", "styling-quick", "true", "styling"));

  // Condition: frontend only?
  const condFrontend = makeNode("cond-frontend", "condition", {
    type: "condition",
    mode: "expression",
    expression: "scope === 'frontend'",
    label: "Frontend only?",
  }, col * X_SPACING, Y_CENTER + Y_SPACING / 2);
  nodes.push(condFrontend);
  edges.push(makeEdge("cond-scope", "cond-frontend", "false"));

  // Quick-edit: frontend
  col++;
  const frontendQuick = makeNode("frontend-quick", "agent", {
    type: "agent",
    agentName: "frontend-dev",
    inputTemplate: "Fix the following issue in the existing code. Use read_file/list_files to inspect relevant files and keep changes minimal and targeted. Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER - Y_SPACING / 2);
  nodes.push(frontendQuick);
  edges.push(makeEdge("cond-frontend", "frontend-quick", "true", "frontend"));

  // Full fix: dev agents
  const devFix = makeNode("dev-fix", "agent", {
    type: "agent",
    agentName: "frontend-dev",
    inputTemplate: "Fix the following issue in the existing code (provided in Previous Agent Outputs as \"project-source\"). Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER + Y_SPACING);
  nodes.push(devFix);
  edges.push(makeEdge("cond-frontend", "dev-fix", "false"));

  // Reviewers (for full fix path)
  col++;
  const codeReview = makeNode("code-review-fix", "agent", {
    type: "agent",
    agentName: "code-review",
    inputTemplate: "Review all code changes made by dev agents (provided in Previous Agent Outputs). Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER + Y_SPACING - Y_SPACING / 2);
  nodes.push(codeReview);
  edges.push(makeEdge("dev-fix", "code-review-fix"));

  const securityFix = makeNode("security-fix", "agent", {
    type: "agent",
    agentName: "security",
    inputTemplate: "Security review all code changes (provided in Previous Agent Outputs). Original request: {{userMessage}}",
  }, col * X_SPACING, Y_CENTER + Y_SPACING + Y_SPACING / 2);
  nodes.push(securityFix);
  edges.push(makeEdge("dev-fix", "security-fix"));

  // Remediation
  col++;
  const remediation = makeNode("remediation-fix", "post-action", {
    type: "post-action",
    actionType: "remediation-loop",
    label: "Remediation",
  }, col * X_SPACING, Y_CENTER + Y_SPACING);
  nodes.push(remediation);
  edges.push(makeEdge("code-review-fix", "remediation-fix"));
  edges.push(makeEdge("security-fix", "remediation-fix"));

  return {
    id: `default-fix-${nanoid(8)}`,
    name: "Default Fix Pipeline",
    description: "Scope-based routing: quick-edit for styling/frontend, full pipeline with reviewers for backend/full",
    intent: "fix",
    version: 1,
    enabled: true,
    nodes,
    edges,
    createdAt: now,
    updatedAt: now,
    isDefault: true,
  };
}

/**
 * Generate the default "question" flow template.
 */
export function generateQuestionDefault(): FlowTemplate {
  const now = Date.now();

  return {
    id: `default-question-${nanoid(8)}`,
    name: "Default Question Pipeline",
    description: "Single orchestrator:question node — answers questions with project context",
    intent: "question",
    version: 1,
    enabled: true,
    nodes: [
      makeNode("question-agent", "agent", {
        type: "agent",
        agentName: "orchestrator:question",
        inputTemplate: "{{userMessage}}",
      }, 0, Y_CENTER),
    ],
    edges: [],
    createdAt: now,
    updatedAt: now,
    isDefault: true,
  };
}

/** Generate all three default templates. */
export function generateAllDefaults(): FlowTemplate[] {
  return [generateBuildDefault(), generateFixDefault(), generateQuestionDefault()];
}
