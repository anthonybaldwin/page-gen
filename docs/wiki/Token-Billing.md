# Token Tracking & Billing

## Overview

Every AI API call is tracked with full metadata. Users can view their usage in a dashboard with drill-down by agent, provider, model, and per-request detail. A permanent billing ledger ensures cost data survives chat and project deletions.

## What Is Tracked

Each API request records:
- **Agent name** — which agent made the call
- **Provider** — anthropic, openai, or google
- **Model** — exact model ID (e.g., claude-sonnet-4-5-20250929)
- **API key hash** — SHA-256 of the key used (never the key itself)
- **Input tokens** — tokens sent to the model
- **Output tokens** — tokens generated by the model
- **Total tokens** — sum of input + output
- **Cost estimate** — USD estimate based on model pricing

Notes:
- For providers that report cache token metadata (for example Anthropic), cached input tokens are split into:
  - non-cached input tokens
  - cache creation tokens
  - cache read tokens
- This prevents double-counting when provider SDK `inputTokens` includes cached tokens.
- Cache token breakdown (creation + read) is surfaced in the usage dashboard: summary cards, grouped views (by agent/model/provider), and per-request log columns.

## Dual-Write Architecture

Token usage is written to **two tables**:

1. **`token_usage`** (operational) — Has FK references to `chats` and `agent_executions`. Deleted when a chat or project is deleted. Used for active session views.
2. **`billing_ledger`** (permanent) — No foreign keys. Never deleted. Includes denormalized `project_name` and `chat_title` snapshots so records are self-contained even after parent entities are removed.

Both tables include an `estimated` column (0 = finalized, 1 = provisional).

A third function, **`trackBillingOnly()`**, writes only to `billing_ledger` for system calls (e.g., API key validation) that have no matching `agentExecutions` or `chats` record and would violate FK constraints on `token_usage`.

This ensures:
- Active session dashboards show real-time operational data
- Lifetime cost tracking is never lost, even after cleanup
- The "Total spent" badge always reflects true lifetime spend
- System calls are tracked for billing without FK violations

## Write-Ahead Token Tracking

To prevent lost billing data when the server crashes mid-pipeline, all LLM call sites use a **two-phase tracking** pattern:

1. **Before the call:** `trackProvisionalUsage()` inserts records with `estimated=1` and estimated input tokens (prompt chars / 4).
2. **After completion:** `finalizeTokenUsage()` updates the records with actual token counts and sets `estimated=0`.
3. **On failure:** `voidProvisionalUsage()` deletes the provisional records so failed calls leave no phantom billing.

If the server crashes between steps 1 and 2, the provisional records survive as best-effort billing. On startup, `cleanupStaleExecutions()` logs the count of provisional records. The `/api/usage/summary` endpoint includes `estimatedTokens` showing the total from unfinalized records.

## Cost Estimation

Pricing is managed by the centralized `pricing.ts` module (`src/server/services/pricing.ts`).

### Default Pricing (per 1M tokens, verified Feb 2026)

| Model | Input | Output |
|-------|-------|--------|
| claude-opus-4-6 | $5 | $25 |
| claude-opus-4-5-20251101 | $5 | $25 |
| claude-sonnet-4-6 | $3 | $15 |
| claude-sonnet-4-5-20250929 | $3 | $15 |
| claude-haiku-4-5-20251001 | $1 | $5 |
| gpt-5.2 | $1.75 | $14 |
| gpt-5.2-pro | $21 | $168 |
| gemini-2.5-flash | $0.30 | $2.50 |

### Pricing Overrides

Pricing can be overridden per-model via Settings > Models or the pricing API. Overrides are stored in the `app_settings` table using `pricing.{model}.input` and `pricing.{model}.output` keys.

- **Known models** use default pricing unless overridden
- **Unknown/custom models** cost **$0** until the user configures pricing (no silent fallback)
- Assigning an unknown model to an agent is blocked until pricing is configured
- Deleting a pricing override reverts a known model to its default pricing

### Cache Token Multipliers

Providers charge different rates for cache creation and cache read tokens relative to standard input pricing. These multipliers are applied during cost estimation.

| Provider | Cache Create | Cache Read |
|----------|-------------|------------|
| Anthropic | 1.25× | 0.1× |
| OpenAI | 0× (no create charge) | 0.5× |
| Google | 0× (no create charge) | 0.25× |
| Default (unknown) | 1.0× | 0.5× |

These multipliers are configurable per-provider via Settings or the API:
- `GET /api/settings/cache-multipliers` — All providers with effective multipliers + `isOverridden` flag
- `PUT /api/settings/cache-multipliers/:provider` — Override `{ create, read }` for a provider
- `DELETE /api/settings/cache-multipliers/:provider` — Revert to defaults

Overrides are stored in the `app_settings` table. The pricing engine (`src/server/services/pricing.ts`) applies these multipliers when computing cost estimates for cache tokens.

### Pricing API

- `GET /api/settings/pricing` — All models with effective pricing + `isOverridden`/`isKnown` flags
- `PUT /api/settings/pricing/:model` — Upsert pricing `{ input, output }`
- `DELETE /api/settings/pricing/:model` — Remove override (reverts known model to default)
- `GET /api/settings/models` — Known models grouped by provider with default pricing

## Safety Limits

All limits are stored in the `app_settings` table and configurable from Settings → Limits.

| Limit | Default | Description |
|-------|---------|-------------|
| Max tokens per chat | 500,000 | Token ceiling per chat session (0 = unlimited) |
| Max agent calls per run | 30 | Hard cap on agent invocations per pipeline |
| Max cost per day | $0 | Daily spending cap across all projects (0 = unlimited) |
| Max cost per project | $0 | Per-project lifetime spending cap (0 = unlimited) |

- **Warning:** Shown at 80% of token limit
- **Pause:** At 100%, orchestration pauses with a clear error message
- Daily cost is summed from `billing_ledger` records with `created_at >= start of day`
- Project cost is summed from `billing_ledger` records matching the project ID

## API Endpoints

### Query Endpoints (from billing_ledger)
- `GET /api/usage` — List all records (filterable by chatId, projectId, from, to)
- `GET /api/usage/chats` — Distinct chats with usage data (for filter dropdowns)
- `GET /api/usage/by-agent` — Grouped by agent
- `GET /api/usage/by-model` — Grouped by provider + model (with optional filters)
- `GET /api/usage/by-provider` — Grouped by provider

### Lifetime (from billing_ledger, includes deleted)
- `GET /api/usage/summary` — Aggregate totals (reads from billing_ledger)
- `GET /api/usage/by-project` — Grouped by project
- `GET /api/usage/history` — Full billing history with optional filters: `?projectId`, `?chatId`, `?from`, `?to`

### Reset
- `DELETE /api/usage/reset` — Clears all rows from `token_usage` and `billing_ledger`. Returns `{ ok: true, deleted: { tokenUsage: N, billingLedger: M } }`. Useful for fresh testing.

## Real-Time Cost Display

A usage badge in the sidebar footer shows:
- **This project** cost for the active project, seeded from billing_ledger on page load and updated in real time via `token_usage` WebSocket events
- **This chat** cost when a chat is active

Clicking the badge opens the full usage dashboard as a modal overlay.

## Dashboard Views (Usage Modal)

1. **Overview** — Total tokens, cost, request count
2. **By Agent** — Token usage per agent
3. **By Provider** — Token usage per provider/model
4. **Request Log** — Per-request detail table (filterable by chat and timeframe)

## Settings Modal

Accessible via the gear icon in the sidebar footer (to the left of the usage badge). Separate from the Usage Dashboard.

1. **API Keys** — Edit or clear provider API keys and proxy URLs
2. **Limits** — Configure spending guardrails (max tokens, agent calls, daily/project cost caps)
3. **Agents** — Per-agent provider and model overrides with pricing visibility (searchable model dropdown, inline pricing display, pricing override via pencil icon, custom model pricing required before save)
4. **Tools** — Per-agent tool assignments (write_file, write_files, read_file, list_files); shows default vs overridden state
5. **Prompts** — View and edit each agent's system prompt with a two-pane editor
6. **Models** — Global model pricing table with per-model overrides; shows known vs custom models with effective pricing
